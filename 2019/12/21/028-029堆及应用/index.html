<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Don">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Don">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>28-29二叉树基础 · Don&#39;s Studio</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Thrones</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">28-29二叉树基础</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Thrones</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            28-29二叉树基础
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "数据结构与算法">数据结构与算法</a>
    
</div>
                
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/12/21</span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>为什么说堆排序没有快速排序快？<br>如何获取到 Top 10 最热门的搜索关键词？<br><a id="more"></a><br>堆这种数据结构应用场景非常多，最经典的莫过于堆排序了。堆排序是一种原地的，时间复杂度为 O(nlogn) 的排序算法。  </p>
<h2 id="如何理解“堆”？">如何理解“堆”？</h2>
<p>只要满足下面两个要求，它就是一个堆。</p>
<ol>
<li>堆是一个完全二叉树</li>
<li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值<br>第一点，堆必须是一个完全二叉树，完全二叉树要求除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。<br>第二点，堆中每个节点的值必须大于等于(或者小于等于)其子树中每个节点的值。实际上，还可以换一种说法，堆中每个节点的值都大于等于(或者小于等于)其左右子节点的值。这两种表述是等价的。<br>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。  </li>
</ol>
<h2 id="如何实现一个堆？">如何实现一个堆？</h2>
<p>之前学过，完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个结点的左右子节点和父节点。<br>下面再来看看，堆上的操作。往堆中插入一个元素和删除堆顶元素，下面都是拿大顶堆来讲解。  </p>
<h3 id="往堆中插入一个元素">往堆中插入一个元素</h3>
<p>往堆中插入一个元素后，我们需要继续满足堆的两个特性。插入后调整，让其重新满足堆的特性，这个过程叫“堆化” (heapify)。<br>堆化实际有两种，从下往上和从上往下。这先讲从下往上的堆化方法。<br>堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。<br>可以让新插入的节点和父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个结点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span></span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] a;<span class="comment">//数组，从下标 1 开始存储数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;<span class="comment">//堆可以存储的最大数据个数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//堆中已经存储的数据个数</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Heap</span>(<span class="keyword">int</span> capacity){</div><div class="line">        a=<span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</div><div class="line">        n=capacity;</div><div class="line">        count=<span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(<span class="keyword">int</span> data){</div><div class="line">        <span class="keyword">if</span>(count&gt;=n) <span class="keyword">return</span>;<span class="comment">//堆满了</span></div><div class="line">        ++count;</div><div class="line">        a[count]=data;</div><div class="line">        <span class="keyword">int</span> i=count;</div><div class="line">        <span class="keyword">while</span>(i/<span class="number">2</span>&gt;<span class="number">0</span> && a[i]&gt;a[i/<span class="number">2</span>]){</div><div class="line">            <span class="comment">//自下往上堆化</span></div><div class="line">            swap(a,i,i/<span class="number">2</span>);<span class="comment">//swap()函数作用：交换下标为 i 和 i/2 的两个元素</span></div><div class="line">            i=i/<span class="number">2</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="删除堆顶元素">删除堆顶元素</h3>
<p>假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，知道叶子节点被删除。<br>不过这种方法有点问题，就是堆化出来的堆并不满足完全二叉树的特性，数组会出现空洞。<br>实际上，我们稍微改变一下思路，就可以解决这个问题。<br>我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，知道父子节点之间满足大小关系为止，这就是<strong>从下往上的堆化方法</strong>。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span>(){</div><div class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//堆中没有数据</span></div><div class="line">    a[<span class="number">1</span>]=a[count];</div><div class="line">    --count;</div><div class="line">    heapify(a,count,<span class="number">1</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span>(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> i){</div><div class="line">    <span class="comment">//自上往下堆化</span></div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>){</div><div class="line">        <span class="keyword">int</span> maxPos=i;</div><div class="line">        <span class="keyword">if</span>(i*<span class="number">2</span>&lt;=n&&a[i]&lt;a[i*<span class="number">2</span>]) maxPos=i*<span class="number">2</span>;<span class="comment">//比较当前节点和它的左子树</span></div><div class="line">        <span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span>&lt;=n&&a[maxPos]&lt;a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos=i*<span class="number">2</span>+<span class="number">1</span><span class="comment">//比较当前节点和它的右子树</span></div><div class="line">        <span class="keyword">if</span>(maxPos==i)<span class="keyword">break</span>;</div><div class="line">        swap(a,i,maxPos);</div><div class="line">        i=maxPos;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们知道，一个包含 n 个几点的完全二叉树，树的高度不会超过 log<sub>2</sub>n 。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 nlogn 。<br>插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 nlogn 。  </p>
<h2 id="如何基于堆实现排序？">如何基于堆实现排序？</h2>
<p>回忆一下前面讲的排序。<br>有O(n<sup>2</sup>)的冒泡排序、插入排序、选择排序，O(nlogn)的归并排序、快速排序，还有线性排序。<br>这里我们借助于堆这种数据结构实现的排序算法就叫做堆排序。这种排序算法非常稳定，是 O(nlogn) ，并且它还是原地排序算法。<br>我们可以把堆排序的过程大致分解成两个大的步骤，建堆和排序。</p>
<h3 id="建堆">建堆</h3>
<p>首先将数组原地建成一个堆。所谓的“原地”就是，不借助另一个数组，就在原数组上操作。建堆的过程有两种思路。</p>
<ol>
<li>第一种是借助我们前面讲的，在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以加水，起初堆中只包含一个数据。就是下标为 1 的数据。然后，我们调用前面讲到的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组成了堆。 </li>
<li>第二种实现思路，跟第一种截然相反。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从第一个非叶子节点开始，依次堆化就行了。<br>下面是第二种实现思路的代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span>(<span class="keyword">int</span>[]a,<span class="keyword">int</span> n){</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;--i){</div><div class="line">        heapify(a,n,i);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span>(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> i){</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>){</div><div class="line">        <span class="keyword">int</span> maxPos=i;</div><div class="line">        <span class="keyword">if</span>(i*<span class="number">2</span>&lt;=n && a[i]&lt;a[i*<span class="number">2</span>]) maxPos=i*<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span>&lt;=n && a[i]&lt;a[i*<span class="number">2</span>]+<span class="number">1</span>) maxPos=i*<span class="number">2</span>+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(maxPos==i) <span class="keyword">break</span>;</div><div class="line">        swap(a,i,maxPos);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从上面代码可以发现，对于下标从 0 到 n/2 的数据进行堆化，下标是 n/2+1 到 n 的数据不需要堆化。实际上，对于完全二叉树来说，下标从 n/2+1 到 n 的节点都是叶子节点。<br>建堆的时间复杂度是 O(n) 。</p>
<h3 id="排序">排序</h3>
<p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。<br>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下 n-1 个元素重新构建成堆。堆化完成后，我们再取堆顶的元素，放到下标是 n 的位置，一直重复这个过程。直到最后堆中只剩下下标为 1 的一个元素，排序工作就完成了。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//n表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n){</div><div class="line">    buildHeap(a,n);</div><div class="line">    <span class="keyword">int</span> k=n;</div><div class="line">    <span class="keyword">while</span>(k&gt;<span class="number">1</span>){</div><div class="line">        swap(a,<span class="number">1</span>,k);</div><div class="line">        --k;</div><div class="line">        heapify(a,k,<span class="number">1</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆的时间复杂度是 O(n) ，排序过程的时间复杂度是 O(nlogn) 。所以，堆排序整体的时间复杂度是 O(nlogn) 。<br>堆排序不是稳定的排序算法，因为在排序的过程中，存在将堆的最后一个结点跟堆顶结点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p>
<h2 id="实际开发中，为什么快速排序比堆排序性能好？">实际开发中，为什么快速排序比堆排序性能好？</h2>
<ol>
<li>堆排序数据访问的方式没有快速排序友好。<ul>
<li>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。堆化过程不像快速排序那样局部顺序访问，这样对 CPU 不友好。</li>
</ul>
</li>
<li>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。  <ul>
<li>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换(或移动)。快速排序数据交换的次数不会比逆序度多。  </li>
<li>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致元数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</li>
</ul>
</li>
</ol>
<h2 id="课后思考">课后思考</h2>
<ol>
<li>讲堆排序的时候说到，对于完全二叉树来说，从 n/2+1 到 n 的都是叶子节点，这个结论是怎么推导出来的呢？<ul>
<li>使用数组存储表示完全二叉树时，从数组下标为1开始存储数据，数组下标为i的节点，左子节点为2i, 右子节点为2i + 1. 这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。</li>
<li>为什么，对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点？ 使用反证法证明即可：</li>
<li>如果下标为n/2 + 1的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：2(n/2 + 1) = n + 2，大家明显可以看出，这个数字已经大于n + 1，超出了实现完全二叉树所用数组的大小（数组下标从1开始记录数据，对于n个节点来说，数组大小是n + 1），左子节点都已经超出了数组容量，更何况右子节点。以此类推，很容易得出：下标大于n/2 + 1的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点</li>
<li>备注下：用数组存储表示完全二叉树时，也可以从下标为0开始，只是这样做的话，计算左子节点时，会多一次加法运算</li>
</ul>
</li>
<li>我们今天讲了堆的一种经典应用，堆排序，你还能想到它的其他应用吗？<ol>
<li>从大数量级数据中筛选出top n 条数据； 比如：从几十亿条订单日志中筛选出金额靠前的1000条数据</li>
<li>在一些场景中，会根据不同优先级来处理网络请求，此时也可以用到优先队列(用堆实现的数据结构)；比如：网络框架Volley就用了Java中PriorityBlockingQueue，当然它是线程安全的</li>
<li>可以用堆来实现多路归并，从而实现有序，leetcode上也有相关的一题：Merge K Sorted Lists</li>
</ol>
</li>
</ol>
<h2 id="堆的应用一：优先级队列">堆的应用一：优先级队列</h2>
<p>优先级队列，它首先是一个队列。队列最大的特性就是先进先出。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的最先出队。<br>实现优先级队列的方法很很多，最直接、高效的。这是因为，堆和优先级队列非常相似。一个堆就可以看做一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素，从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。<br>优先级队列的应用场景非常多，后面讲的很多数据结构和算法都要依赖它。比如，赫夫曼编码、图的最短路径、最小生成树算法等等。不仅如此，很多语言中都提供了优先级队列的实现，比如，Java 的 PriorityQueue ，C++ 的 priority_queue 等。<br>下面举两个具体的例子</p>
<h3 id="合并有序小文件">合并有序小文件</h3>
<p>假设我们有 100 个小文件，每个文件的大小是 100MB ，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件，这里就会用到优先级队列。<br>整体思路有点像归并排序中的合并函数。我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。<br>假设，这个最小的字符串来自于 13.txt 这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。以此类推，知道所有的文件中的数据都放入到大文件为止。这里我们用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取消字符串，都需要循环遍历整个数组，显然并不高效。有没有更加高效方法呢？  </p>
<p>这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。<br>我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是 O(logn) 。比原来数组存储的方式高效了很多。</p>
<h3 id="高性能定时器">高性能定时器</h3>
<p>假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的时间单位(比如 1 秒)，就扫描一遍任务，看是否有任务到大设定的执行时间。如果达到了，就拿出来执行。<br>但是，这样没过疫苗执行任务列表的做法比较低效。因为一、任务约定执行时间里当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的。二、每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。  </p>
<p>针对这些问题，我们就可以用优先级队列来解决。我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部(也就是小顶堆的堆顶)存储的是最先执行的任务。<br>这样，定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T 。<br>这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到 (T-1) 秒这段时间里，定时器都不需要做任何事情。<br>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。<br>这样，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。  </p>
<h2 id="堆的应用二：利用堆求_Top_K">堆的应用二：利用堆求 Top K</h2>
<p>大佬把这种求 Top K 的问题抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。<br>针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组汇总取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中。如果比堆顶元素小，则不作处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。<br>遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK)，所以最好情况下， n 个元素都入堆一次，时间复杂度就是 O(nlogK)。<br>针对动态数据求得 Top K 就是实时 Top K 。举例，一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。<br>如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，时间复杂度就是 O(nlogK)，n 表示当前数据的大小。实际上，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就那它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中。如果比堆顶元素小，则不作处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。  </p>
<h2 id="堆的应用三：利用堆求中位数">堆的应用三：利用堆求中位数</h2>
<p>中位数，如果数据的个数是奇数，把数据从小到大排列，第 n/2 个数据就是中位数，如果数据是偶数的话，那处于中间位置的数据有两个，第 n/2 和第 n/2+1 个，这个时候，可以随意取一个作为中位数，比如取两个数中靠前的那个。<br>对于一组静态数据，中位数是固定的，我们可以先排序。第 n/2 个数据就是中位数。每次询问中位数的时候，直接返回这个固定的值就好了。所以尽管排序的代价比较大，但是边际成本会很小。但是，如果我们面对的是动态数据集合，中位数在不停地变动，如果再用先排序的方法，每次询问中位数的时候都要先进行排序，那效率就不高了。<br>借助堆这种数据结构，不用排序就可以非常高效地实现求中位数的操作。  </p>
<p>我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。<br>也就是说，如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2 个数据存储在大顶堆中，后 n/2+1 个数据存储在小顶堆中。这样大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储 n/2+1 个数据，小顶堆就存储 n/2 个数据。<br>数据是动态变化的，当新加入一个数据的时候，如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆，否则，我们就将这个新数据插入到小顶堆。这个时候可能就出现两个堆中的数据个数不符合前面约定的情况：如果 n 是偶数，两个堆中的个数都是 n/2 。如果 n 是奇数，大顶堆有 n/2+1 个，小顶堆有 n/2 个数据。这个时候，我们可以从一个堆中不停地将堆顶圆度移动到另一个堆，通过这样的调整，让两个堆中的数据满足上面的约定。<br>于是，就可以利用两个堆，一个大顶堆、一个小顶堆，实现在动态数据集合中求中位数的操作。插入数据因为要涉及堆化，时间复杂度是 O(logn)，但是求中位数我们只需要返回大顶堆的堆顶元素就可以，所以时间复杂度就是 O(1)。<br>实际上，利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，原理是类似的。<br>比如说，如何求 90% 的响应时间？<br>维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 n 。大顶堆中保存 n<em>99% 个数据，小顶堆中保存 n </em>1% 个数据。大顶堆堆顶的数据就是我们要找的 99% 响应时间。其他类似求中位数的操作。  </p>
<h2 id="如何获取到_Top_10_最热门的搜索关键词？">如何获取到 Top 10 最热门的搜索关键词？</h2>
<p>假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？<br>处理这个问题有很多高级的解决方法，比如 MapReduce 等。如果我们将处理的场景限定为单机，可以使用的内存为 1GB 。这个问题该如何解决呢？<br>因为用户搜索的关键词，有很多可能都是重复的，所以我们首先要统计每个搜索关键词出现的频率，我们可以通过散列表、平衡二叉查找树或者其他一些支持快速查找、插入的数据结构，来记录关键词及其出现的次数。<br>假设我们选用散列表。我们就顺序扫描这 10 亿个搜索关键词。当扫描到某个关键词时，就去散列表中查询。如果存在，就将对应的次数加一，如果不存在，我们就将它插入到散列表，并记录次数为 1 。以此类推，等遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数。<br>然后，我们再根据前面讲的用堆求 Top K 的方法，建立大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，两这个出现次数更多的关键词加入到堆中。<br>以此类推，当遍历完整个散列表中的搜索关键词之后，堆中的搜索关键词就是出现次数最多的 Top 10 搜索关键词了。<br>但是上面的方法，1GB 的内存不够用，怎么办呢？<br>哈希算法中讲过，相同数据经过哈希算法得到的哈希值是一样的。我们可以根据哈希算法这个特点，将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中。<br>具体可以这样做：创建 10 个空文件 00,01,02,…09。我们遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。这样每个文件有 1 亿个关键词，内存可以放得下。我们针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10，然后把这 10 个 Top 10 放在一块，然后取出这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了。  </p>
<h2 id="课后思考-1">课后思考</h2>
<ul>
<li>有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每隔 1 小时更新一次。如果你是负责开发这个功能的工程师，你会如何来实现呢？</li>
</ul>
<ol>
<li>对每篇新闻摘要计算一个hashcode，并建立摘要与hashcode的关联关系，使用map存储，以hashCode为key，新闻摘要为值</li>
<li>按每小时一个文件的方式记录下被点击的摘要的hashCode</li>
<li>当一个小时结果后，上一个小时的文件被关闭，开始计算上一个小时的点击top10</li>
<li>将hashcode分片到多个文件中，通过对hashCode取模运算，即可将相同的hashCode分片到相同的文件中</li>
<li>针对每个文件取top10的hashCode，使用Map&lt;hashCode,int&gt;的方式，统计出所有的摘要点击次数，然后再使用小顶堆（大小为10）计算top10,</li>
<li>再针对所有分片计算一个总的top10,最后合并的逻辑也是使用小顶堆，计算top10</li>
<li>如果仅展示前一个小时的top10,计算结束</li>
<li>如果需要展示全天，需要与上一次的计算按hashCode进行合并，然后在这合并的数据中取top10</li>
<li>在展示时，将计算得到的top10的hashcode，转化为新闻摘要显示即可</li>
</ol>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://yoursite.com">Don</a>
            <p>原文链接：<a href="http://yoursite.com/2019/12/21/028-029堆及应用/">http://yoursite.com/2019/12/21/028-029堆及应用/</a>
            <p>发表日期：<a href="http://yoursite.com/2019/12/21/028-029堆及应用/">December 21st 2019, 12:00:00 am</a>
            <p>更新日期：<a href="http://yoursite.com/2019/12/21/028-029堆及应用/">December 22nd 2019, 12:08:14 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2019/12/19/023-024二叉树基础/" title= "23-24二叉树基础">
                    <div class="prevTitle">23-24二叉树基础</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:798937300@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/Don1110" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/example_qr.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何理解“堆”？"><span class="toc-number">1.</span> <span class="toc-text">如何理解“堆”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何实现一个堆？"><span class="toc-number">2.</span> <span class="toc-text">如何实现一个堆？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#往堆中插入一个元素"><span class="toc-number">2.1.</span> <span class="toc-text">往堆中插入一个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除堆顶元素"><span class="toc-number">2.2.</span> <span class="toc-text">删除堆顶元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何基于堆实现排序？"><span class="toc-number">3.</span> <span class="toc-text">如何基于堆实现排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#建堆"><span class="toc-number">3.1.</span> <span class="toc-text">建堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">3.2.</span> <span class="toc-text">排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实际开发中，为什么快速排序比堆排序性能好？"><span class="toc-number">4.</span> <span class="toc-text">实际开发中，为什么快速排序比堆排序性能好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#课后思考"><span class="toc-number">5.</span> <span class="toc-text">课后思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的应用一：优先级队列"><span class="toc-number">6.</span> <span class="toc-text">堆的应用一：优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#合并有序小文件"><span class="toc-number">6.1.</span> <span class="toc-text">合并有序小文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高性能定时器"><span class="toc-number">6.2.</span> <span class="toc-text">高性能定时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的应用二：利用堆求_Top_K"><span class="toc-number">7.</span> <span class="toc-text">堆的应用二：利用堆求 Top K</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的应用三：利用堆求中位数"><span class="toc-number">8.</span> <span class="toc-text">堆的应用三：利用堆求中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何获取到_Top_10_最热门的搜索关键词？"><span class="toc-number">9.</span> <span class="toc-text">如何获取到 Top 10 最热门的搜索关键词？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#课后思考-1"><span class="toc-number">10.</span> <span class="toc-text">课后思考</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 64
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href= "/2019/12/21/028-029堆及应用/" >28-29二叉树基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/19</span><a class="archive-post-title" href= "/2019/12/19/023-024二叉树基础/" >23-24二叉树基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/17</span><a class="archive-post-title" href= "/2019/12/17/21-22哈希算法/" >21-22哈希算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/15</span><a class="archive-post-title" href= "/2019/12/15/18-20散列表/" >18-20散列表</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/14</span><a class="archive-post-title" href= "/2019/12/14/017跳表/" >17跳表</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/13</span><a class="archive-post-title" href= "/2019/12/13/015-016二分查找（上下）/" >15-16二分查找（上下）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2019/12/11/014排序优化/" >13排序优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/10</span><a class="archive-post-title" href= "/2019/12/10/013线性排序/" >13线性排序</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/05</span><a class="archive-post-title" href= "/2019/12/05/012排序（下）/" >12排序（下）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/29</span><a class="archive-post-title" href= "/2019/11/29/011排序（上）/" >11排序（上）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/28</span><a class="archive-post-title" href= "/2019/11/28/009队列/" >09队列</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/28</span><a class="archive-post-title" href= "/2019/11/28/010递归/" >10递归</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/24</span><a class="archive-post-title" href= "/2019/11/24/008栈/" >08栈</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/23</span><a class="archive-post-title" href= "/2019/11/23/005数组链表/" >05-07 数组和链表</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/21</span><a class="archive-post-title" href= "/2019/11/21/003复杂度分析/" >03-04复杂度分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/06</span><a class="archive-post-title" href= "/2019/09/06/27-28解释器模式和访问者模式/" >27-28解释器模式和访问者模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/03</span><a class="archive-post-title" href= "/2019/09/03/25中介者模式/" >25中介者模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/03</span><a class="archive-post-title" href= "/2019/09/03/26享元模式/" >26享元模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2019/09/02/24职责链模式/" >24职责链模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/31</span><a class="archive-post-title" href= "/2019/08/31/23命令模式/" >23命令模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/29</span><a class="archive-post-title" href= "/2019/08/29/22桥接模式/" >22桥接模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/27</span><a class="archive-post-title" href= "/2019/08/27/20-21迭代器模式和单例模式/" >20-21迭代器模式和单例模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span><a class="archive-post-title" href= "/2019/08/26/19组合模式/" >19组合模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/22</span><a class="archive-post-title" href= "/2019/08/22/18备忘录模式/" >18备忘录模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/22</span><a class="archive-post-title" href= "/2019/08/22/17适配器模式/" >17适配器模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href= "/2019/08/21/16状态模式/" >16状态模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/18</span><a class="archive-post-title" href= "/2019/08/18/15抽象工厂模式/" >15抽象工厂模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/16</span><a class="archive-post-title" href= "/2019/08/16/14观察者模式/" >14观察者模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/15</span><a class="archive-post-title" href= "/2019/08/15/ES-Java从ES中读取表/" >ES-使用Spring-data从ES中读取表</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/07</span><a class="archive-post-title" href= "/2019/08/07/13建造者模式/" >13建造者模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/02</span><a class="archive-post-title" href= "/2019/08/02/Linux-端口经验/" >Linux-端口经验</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/02</span><a class="archive-post-title" href= "/2019/08/02/11-12迪米特法则和外观模式/" >11-12迪米特法则和外观模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/31</span><a class="archive-post-title" href= "/2019/07/31/9-10原型模式和模板方法模式/" >9-10原型模式和模板方法模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2019/07/30/8工厂方法模式/" >8工厂方法模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/26</span><a class="archive-post-title" href= "/2019/07/26/6-7装饰模式和代理模式/" >6-7装饰模式和代理模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2019/07/25/3-5单一职责原则、开闭原则、依赖倒转原则/" >3-5单一职责原则、开闭原则、依赖倒转原则</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href= "/2019/07/24/1-2简单工厂模式和策略模式/" >1-2简单工厂模式和策略模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/19</span><a class="archive-post-title" href= "/2019/07/19/Java030/" >面向对象基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/19</span><a class="archive-post-title" href= "/2019/07/19/0面向对象基础/" >面向对象基础</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/17</span><a class="archive-post-title" href= "/2018/11/17/Java028/" >Java学习-章节28-29</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/16</span><a class="archive-post-title" href= "/2018/11/16/Java026/" >Java学习-章节26-27</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/11</span><a class="archive-post-title" href= "/2018/11/11/Java024/" >Java学习-章节24-25</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span><a class="archive-post-title" href= "/2018/11/03/Java019/" >Java学习-章节19-23</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span><a class="archive-post-title" href= "/2018/11/03/Java17/" >Java学习-章节17-18</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/30</span><a class="archive-post-title" href= "/2018/10/30/Java016/" >Java学习-章节16</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/29</span><a class="archive-post-title" href= "/2018/10/29/TensorFlow/" >TensorFlow学习(1)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/29</span><a class="archive-post-title" href= "/2018/10/29/TensorFlow2/" >TensorFlow学习(2)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2018/10/28/Java015/" >Java学习-章节15</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href= "/2018/10/26/Java014/" >Java学习-章节14</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href= "/2018/10/26/Java012/" >Java学习-章节12</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href= "/2018/10/26/Java013/" >Java学习-章节13</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href= "/2018/10/26/Java011/" >Java学习-章节11</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/25</span><a class="archive-post-title" href= "/2018/10/25/Java010/" >Java学习-章节10</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/22</span><a class="archive-post-title" href= "/2018/10/22/Java009/" >Java学习-章节9</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/14</span><a class="archive-post-title" href= "/2018/10/14/Java008/" >Java学习-章节8</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/12</span><a class="archive-post-title" href= "/2018/10/12/Java007/" >Java学习-章节7</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/11</span><a class="archive-post-title" href= "/2018/10/11/Java005/" >Java学习-章节5</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/11</span><a class="archive-post-title" href= "/2018/10/11/Java004/" >Java学习-章节4</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/11</span><a class="archive-post-title" href= "/2018/10/11/Java006/" >Java学习-章节6</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2018/10/10/addCourse/" >添加往年课程教材</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/Java003/" >Java学习-章节3</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/04</span><a class="archive-post-title" href= "/2018/10/04/Java002/" >Java学习-章节2</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/03</span><a class="archive-post-title" href= "/2018/10/03/Java001/" >Java学习-章节1</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/20</span><a class="archive-post-title" href= "/2018/03/20/git/" >git 学习笔记</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="数据结构与算法"><span class="iconfont-archer">&#xe606;</span>数据结构与算法</span>
    
        <span class="sidebar-tag-name" data-tags="设计模式"><span class="iconfont-archer">&#xe606;</span>设计模式</span>
    
        <span class="sidebar-tag-name" data-tags="Elasticsearch"><span class="iconfont-archer">&#xe606;</span>Elasticsearch</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="面向对象"><span class="iconfont-archer">&#xe606;</span>面向对象</span>
    
        <span class="sidebar-tag-name" data-tags="操作系统"><span class="iconfont-archer">&#xe606;</span>操作系统</span>
    
        <span class="sidebar-tag-name" data-tags="git"><span class="iconfont-archer">&#xe606;</span>git</span>
    
        <span class="sidebar-tag-name" data-tags="Python"><span class="iconfont-archer">&#xe606;</span>Python</span>
    
        <span class="sidebar-tag-name" data-tags="UCAS"><span class="iconfont-archer">&#xe606;</span>UCAS</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="算法"><span class="iconfont-archer">&#xe60a;</span>算法</span>
    
        <span class="sidebar-category-name" data-categories="Java学习"><span class="iconfont-archer">&#xe60a;</span>Java学习</span>
    
        <span class="sidebar-category-name" data-categories="图数据库"><span class="iconfont-archer">&#xe60a;</span>图数据库</span>
    
        <span class="sidebar-category-name" data-categories="Linux学习"><span class="iconfont-archer">&#xe60a;</span>Linux学习</span>
    
        <span class="sidebar-category-name" data-categories="☎-经验累积"><span class="iconfont-archer">&#xe60a;</span>☎-经验累积</span>
    
        <span class="sidebar-category-name" data-categories="☎-经验累积/其他"><span class="iconfont-archer">&#xe60a;</span>☎-经验累积/其他</span>
    
        <span class="sidebar-category-name" data-categories="NLP"><span class="iconfont-archer">&#xe60a;</span>NLP</span>
    
        <span class="sidebar-category-name" data-categories="教程"><span class="iconfont-archer">&#xe60a;</span>教程</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Don"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


